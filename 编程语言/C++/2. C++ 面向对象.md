#### 1. 类与对象
1. 头文件（声明）
   - 包含：头文件保护、必要依赖、前向声明、类+函数声明、全局常量constexpr、共享变量inline、模板、宏
     - 命名空间：全局命名空间（外部链接）、匿名空间（内部链接）、外部不可见（using 引入）
     - 模板：函数/类/变量在头文件中完整定义，编译期实例化，无独立符号
     - inline 函数/变量：允许多次定义（链接器合并），共享单一实例
       - 类内成员函数：隐式 inline（显式 inline 提高可读性）
     - constexpr函数/变量：隐式inline，可能在编译期求值
     - static const/constexpr 成员：类共享，整数型可类内初始化，非整数型需 .cpp 文件定义

2. 三种访问修饰符
   - class 默认 private；struct 默认 public
     - public：公共接口、常量、工具函数、需被广泛访问的成员
     - private：内部状态、辅助函数
     - protected：派生类所需成员、允许扩展
   - private：数据成员、辅助函数、实现细节
   - 不适合private：接口函数、需要继承的成员、静态成员

#### 2. 构造、析构、拷贝构造、拷贝赋值、移动构造、移动赋值
- 特殊成员函数：管理对象的创建、销毁和复制/移动
  - 通常为 public（接口），可设为 private/protected 限制访问
  - 显示默认 `= default`、显示删除 `= delete`
    ```
    构造函数：初始化对象。
    析构函数：清理对象。
    拷贝构造函数：通过同类型对象复制初始化。
    拷贝赋值运算符：通过同类型对象赋值。
    移动构造函数（C++11起）：通过临时对象移动初始化。
    移动赋值运算符（C++11起）：通过临时对象移动赋值。
    ```
  1. 构造函数：默认（无参数或默认值）、带参数、委托、explicit、delete
     - 默认生成调用默认初始化（const 或引用成员无法默认初始化）
     - 若定义了带参数构造函数，需显式定义默认构造函数
  2. 析构函数：不可重载、不可抛出异常、可为 virtual（多态析构）
     - 按构造相反顺序调用所有成员和基类的析构函数
     - 基类析构函数应为 virtual，确保派生类正确销毁
     - 抽象类可定义纯虚析构（需实现）
  3. 拷贝构造函数：const 引用参数、默认逐成员浅拷贝
     - 定义移动构造函数/赋值运算符可能抑制默认拷贝构造函数生成
     - 初始化新对象、函数传参、返回临时值时触发
  4. 拷贝赋值运算符：const 引用参数、返回 *this 支持链式赋值、自赋值安全
     - 定义移动构造函数/赋值运算符可能抑制默认拷贝赋值生成
     - 惯用拷贝构造函数简化赋值 `std::swap(ptr, other.ptr);`
  5. 移动构造函数：右值引用、将other置于有效但未定义、noexcept提高性能
     - 定义拷贝造函数/赋值运算符可能抑制默认拷贝赋值生成
     - 标 noexcept 让容器选择移动而非拷贝
  6. 移动赋值运算符：同移动构造函数、通常返回 *this、自赋值安全
  - 关键字组合
    ```
    static：类共享的成员变量或成员函数，不适用构造函数（无this）
    const：拷贝/移动函数常接收 const 引用。
    inline：类内定义默认隐式 inline
    constexpr：编译期可求值的成员函数或 static 成员变量
    ```
  - 编译器优化
    - 返回值优化：编译器在调用者分配的栈空间直接构造返回对象
      - RVO：返回临时对象（`return T();`）时，编译器在调用者的目标对象上构造
      - NRVO：返回命名对象（`return obj;`）时，，编译器在调用者的目标对象上构造
      - 禁用 RVO/NRVO 优化（如 GCC 的-fno-elide-constructors）强制拷贝/移动
    - 移动语义：通过转移资源（如指针所有权）替代拷贝，适用于右值场景
      - 触发于右值引用（显式std::move、返回/传递临时对象）
      - 如果 RVO 失败（如禁用优化），移动构造函数可能触发（右值场景）

#### 3. 继承与派生（多态、多重继承、菱形继承）
1. 构造析构顺序
    ```
    Base Constructor
    Derived Constructor
    Derived Destructor
    Base Destructor
    ```
2. 多态（重写基类虚函数 `virtual` `override`）
   - 编译时多态（静态多态）：通过函数重载和模板实现，编译期决议调用哪个函数
   - 运行时多态（动态多态）：通过继承和虚函数实现，依赖运行时动态绑定（基于对象实际类型）
     - 虚函数：`virtual` 函数，允许重写 `override`，有间接调用开销
       - 虚函数表 vtable（编译时生成）：存储虚函数的地址，按继承层次组织
       - 虚函数指针 vptr：对象内存布局中的指针，指向该类对应的 vtable
       - 虚析构函数：避免析构不完整（仅调用基类析构，派生类资源未释放）
         - 纯虚析构：必须提供实现，强制抽象性
     - 动态绑定：通过基类指针或引用调用虚函数，运行时根据对象类型调用
     - 抽象类：包含纯虚函数的类，定义接口，不可实例化
       - 纯虚函数 `virtual = 0`：派生类必须实现、需显式调用基类所实现的纯虚函数
     - final：禁止继承（防止用作基类）、禁止重写（防止派生类重写）
3. 虚继承（多重继承、菱形继承）
   - 多重继承：一个派生类同时继承多个基类（常用于继承抽象基类（接口））
     - 二义性：多个基类有同名成员，访问时需显式指定基类，可用 `using` 或重写
   - 菱形继承问题：基类的成员存在多个副本（二义性）、资源重复分配/释放
     - 虚继承：通过 vbptr 实现，基类在多重继承中只存在一份实例、虚基类由最底层派生类构造
        ```cpp
        class B : virtual public A {};
        class C : virtual public A {};
        class D : public B, public C {};
        ```


