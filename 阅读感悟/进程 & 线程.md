#### 1. 多进程调度
操作系统内核负责分配CPU资源给多个进程的机制

1. 进程状态（七个）：创建、就绪、阻塞、运行、就绪挂起、阻塞挂起、结束
    ```
    +-----------------------------
    |                            ↑
    |                          运行状态 →结束→ 结束状态
    |                        ↗↙     ↘等待事件
    |                  调度↗↙时间片用完 ↘
    | 创建状态 →就绪队列→ 就绪状态 ←事件完成← 阻塞状态
    |          ↘          ↑↓                 ↑↓
    +----------→     就绪挂起状态 ←事件出现← 阻塞挂起状态
    ```
    ```
    +-------------------+
    | Main Memory       |
    | [PCB Table]       |
    |  A: [PID: 1 | Running | PC: 0x2000 | SP: 0x1000] | ← CPU执行
    |  B: [PID: 2 | Ready   | PC: 0x3000 | SP: 0x2000] | ← 待调度
    +-------------------+
    | CPU: PC=0x2000    | ← 当前运行A
    | Timer: 超时信号   | ← 触发切换
    +-------------------+
    ```
   - 调度与切换
        ```
        [PCB_A: Running] → Timer中断 → [保存PC=0x2004, Ready]
        [PCB_B: Ready]   → 调度选择 → [加载PC=0x3000, Running]
        ```
2. 多进程调度
   1. 调度算法：CFS（完全公平调度）为主，辅以实时调度（SCHED_FIFO、SCHED_RR）
      - 先来先服务（FCFS, First-Come, First-Serve）：按进程到达顺序执行
      - 短作业优先（SJF, Shortest Job First）：优先执行预计运行时间最短的进程
      - 优先级调度：根据进程优先级分配CPU，可能导致低优先级进程“饿死”
      - 时间片轮转（Round-Robin）：每个进程分配固定时间片，时间到后切换到下一个就绪进程（分时系统）
      - 多级反馈队列（MLFQ）：结合优先级和时间片，动态调整进程优先级
   2. 调度关键点
      - 上下文切换：进程切换时，操作系统保存当前进程的状态并加载新进程的状态
      - 抢占式：允许中断正在运行的进程以运行更高优先级的进程（如Linux）
      - 非抢占式：进程运行直到完成或主动让出CPU（如早期Windows）

   3. 进程间通信 IPC
      1. 管道（简单）：匿名管道：用于父子进程间的单向通信；命名管道：允许非亲缘进程通信，支持双向数据流
      2. 消息队列（异步）：异步通信，结构化数据传递，但需要额外管理队列
      3. 共享内存（高速）：读写速度快，但需要同步机制避免数据竞争（如使用信号量）
      4. 信号（轻量）：仅传递简单事件信息
      5. 套接字：网络或本地进程间通信，支持跨主机通信
      6. 文件：适合持久化数据交换，但速度慢

   4. 进程同步
      1. 同步问题：竞争条件（多进程同时访问共享资源）、临界区（访问共享资源的代码段）
      2. 同步机制
         - 互斥锁：确保同一时刻只有一个进程进入临界区
         - 信号量：P（wait，减少计数）、V（signal，增加计数）
         - 条件变量：进程在特定条件满足时等待或唤醒其他进程，常与互斥锁配合使用
         - 读写锁：允许多个读者同时访问，但写者独占资源，适合读多写少的场景
      3. 死锁与避免
         - 死锁：多个进程互相等待对方释放资源，导致全部阻塞
         - 死锁条件：互斥、占有并等待、非抢占、进程间形成等待环

#### 2. 多线程调度
- 多任务：现代操作系统允许多个线程并发运行，但CPU核心数有限（例如4核运行100个线程）
1. 线程类型
   - 用户级线程（快速但易阻塞进程）：由线程库（如pthread）管理，内核不可见；
   - 内核级线程（慢速但支持多核并行）：由内核直接管理，调度更灵活；

2. 任务分类与优先级
   - 实时任务：0~99，要求高响应性
     - 调度类与策略
       - Deadline (SCHED_DEADLINE)：按截止时间排序，最近截止任务优先
       - Realtime：
         SCHED_FIFO：同优先级先来先服务，高优先级可抢占
         SCHED_RR：同优先级轮转（时间片），高优先级可抢占
   - 普通任务调度（100~139，Fair 类，由 CFS 管理）
     - 调度类与策略
       - SCHED_NORMAL：普通任务策略
       - SCHED_BATCH：后台任务，降低优先级，不干扰交互任务
   - 完全公平调度（CFS）：优先选择 vruntime 少的任务
     - vruntime = 实际运行时间 * NICE_0_LOAD / 权重
3. CPU 运行队列 Deadline > Realtime > Fair
     dl_rq：Deadline 任务
     rt_rq：实时任务
     cfs_rq：普通任务（红黑树，按 vruntime 排序，最左侧节点优先）
4. 线程同步（进程同步类似）
   1. 同步机制
      - 互斥锁（Mutex）：确保同一时刻只有一个线程进入临界区
      - 读写锁：允许多个线程同时读，但写操作独占
      - 信号量：控制多个线程对有限资源的访问，如sem_wait() P和sem_post() V
      - 条件变量：线程等待特定条件（如队列非空）并被其他线程唤醒
      - 原子操作：无锁同步，通过硬件支持的原子指令（如compare-and-swap）

5. 经典问题
   1. 五位哲学家就餐（设计同步机制，确保不会死锁、饥饿，尽可能提高并发性）
      - 竞态条件：多个哲学家竞争使用筷子
      - 死锁风险：哲学家循环等待筷子
      - 饥饿风险：哲学家可能因调度不公而长期无法获取两根筷子
      - 同步方案
        1. 资源分级（避免死锁，但降低并发）：先拿编号较低的筷子，再拿编号较高的筷子
        2. 仲裁者（简单，但性能受服务员制约）：服务员确保最多只有四位哲学家同时尝试拿筷子
        3. 尝试与回退（简单，但可能活锁）：如果无法同时获取，则放下已拿的筷子，等待后重试
        4. 信号量限制：每根筷子用互斥锁保护，哲学家在吃饭前后操作信号量

   2. 读者-写者问题（设计同步机制，确保数据一致性、避免饥饿，尽可能提高并发性）
      - 同步方案
        1. 简单互斥锁（性能差）：读写操作都需获取锁
        2. 读写锁（可能导致一方饥饿）：多个读者共享锁，写者独占锁
        3. 信号量 + 计数器：用信号量控制读写访问，用计数器记录当前读者数量