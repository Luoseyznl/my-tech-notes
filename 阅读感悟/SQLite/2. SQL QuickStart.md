## 1. 数据库事务 ACID 特性
Atomicity（原子性）：事务中的操作要么全部执行，要么全部不执行
Consistency（一致性）：事务执行前后，数据库状态必须保持一致（不被破坏）
Isolation（隔离性）：并发事务之间互不影响
Durability（持久性）：事务一旦提交，结果永久保存

## 2. Quick Start SQLite
1. 建立数据库
    ```sh
    sqlite3 test.db
    ```
2. TCL(Tool Command Language)程序
    ```sh
    01  #!/usr/bin/tclsh                    ; 指定用 tclsh 解释器运行脚本
    02  if {$argc!=2} {                     ; 判断参数数量是否为2
    03    puts stderr "Usage: %s DATABASE SQL-STATEMENT"
    04    exit 1                            ; 退出程序
    05  }
    06  package require sqlite3             ; 加载 sqlite3 包
    07  sqlite3 db [lindex $argv 0]         ; 用第一个参数作为数据库文件打开
    08  db eval [lindex $argv 1] x {        ; 用第二个参数作为 SQL 语句执行
    09    foreach v $x(*) {                 ; 遍历结果集的每个字段
    10      puts "$v = $x($v)"              ; 输出字段名和值
    11    }
    12    puts ""                           ; 输出空行分隔
    13  }
    14  db close                            ; 关闭数据库连接
    ```
3. C/C++ 程序
    ```c
    #include <stdio.h>
    #include <sqlite3.h>

    static int callback(void *data, int argc, char **argv, char **azColName) {
        for (int i = 0; i < argc; i++) {
            printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
        }
        printf("\n");
        return 0;
    }

    int main(int argc, char *argv[]) {
        if (argc != 3) {
            fprintf(stderr, "Usage: %s DATABASE SQL-STATEMENT\n", argv[0]);
            return 1;
        }

        sqlite3 *db;
        char *errMsg = 0;

        if (sqlite3_open(argv[1], &db)) {
            fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
            return 1;
        }

        if (sqlite3_exec(db, argv[2], callback, 0, &errMsg) != SQLITE_OK) {
            fprintf(stderr, "SQL error: %s\n", errMsg);
            sqlite3_free(errMsg);
        }

        sqlite3_close(db);
        return 0;
    }
    ```
