> 动态规划核心思想：避免重复计算

### 1 01背包问题
第 i（i 从1开始）件物品的重量为 w[i]，价值为 v[i]，能够装入背包的最大价值是多少？
- 本质：组合优化的 NP 完全问题
1. 动态规划：`dp[i][j]` 表示前 `i` 个物品放入 限重为 `j` 的背包的最大价值
2. `dp[i][j]` 两种情况：`dp[i-1][j]` or `dp[i-1][j-w[i]] + v[i]`（装入或不装入第 i 个物品）
3. 状态转移方程：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) // j >= w[i]`
   - `dp[i][j]` 仅与 `dp[i-1][0,...,j-1]` 有关 ==> 采用滚动数组优化（去掉第一维，**逆向枚举**）
   - 伪代码
        ```
        // 空间优化、逆向枚举
        dp[0,...,W] = 0
        for i = 1 : N
            for j = W : w[i]
                dp[j] = max(dp[j], dp[j-w[i]] + v[i])
        ```
### 2 完全背包
N 种物品各无限多个，第i（i从1开始）件物品的重量为 w[i]，价值为 v[i]，能够装入背包的最大价值是多少？
1. 动态规划：仍然用 `dp[i][j]` 表示前 `i` 种物品放入 限重为 `j` 的背包的最大价值
2. 状态转移方程：`dp[i][j]` 两种情况：`dp[i-1][j]` or `dp[i][j-w[i]] + v[i]`（区别）
   - 仍采用滚动数组优化，但**正向枚举**（每一次的规划都要覆盖上一次）

        ```
        \\ 空间优化、正向枚举
        dp[0,...,W] = 0
        for i = 1 : N
            for j = w[i] : W
                dp[j] = max(dp[j], dp[j-w[i]] + v[i])
        ```
3. 另一种思路，k为装入第i种物品的件数：`dp[i][j] = max{(dp[i-1][j − k*w[i]] + k*v[i]) for every k}`
    ```
    dp[0,...,W] = 0
    for i = 1 : N
        for j = W : w[i] // 逆向枚举
            for k = 0 : j/w[i]
                dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i])
    ```

### 3 多重背包
有限 n[i] 个 N 种物品，第i（i从1开始）件物品的重量为 w[i]，价值为 v[i]，能够装入背包的最大价值是多少？


