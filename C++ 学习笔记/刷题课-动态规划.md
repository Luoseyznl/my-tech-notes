> 动态规划核心思想：避免重复计算

### 1 01背包问题
- 本质：组合优化的 NP 完全问题
第 i（i 从1开始）件物品的重量为 w[i]，价值为 v[i]，能够装入背包的最大价值是多少？
1. 动态规划：`dp[i][j]` 表示前 `i` 个物品放入 限重为 `j` 的背包的最大价值
2. `dp[i][j]` 两种情况：`dp[i-1][j]` or `dp[i-1][j-w[i]] + v[i]`（装入或不装入第 i 个物品）
3. 状态转移方程：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])`
   - `dp[i][j]` 仅与 `dp[i-1][0,...,j-1]` 有关 ==> 采用滚动数组优化（去掉第一维）+ **逆向枚举**
   - 伪代码
        ```
        // 空间优化、逆向枚举
        dp[0,...,W] = 0
        for i = 1 : N
            for j = W : w[i]
                dp[j] = max(dp[j], dp[j-w[i]] + v[i])
        ```
### 2 完全背包
N 种物品各无限多个，第i（i从1开始）件物品的重量为 w[i]，价值为 v[i]，能够装入背包的最大价值是多少？
1. 动态规划：仍然用 `dp[i][j]` 表示前 `i` 种物品放入 限重为 `j` 的背包的最大价值
2. 状态转移方程：`dp[i][j]` 两种情况：`dp[i-1][j]` or `dp[i][j-w[i]] + v[i]`（区别）
   - 仍采用滚动数组优化，但**正向枚举**（每一次的规划都要覆盖上一次）

        ```
        \\ 空间优化、正向枚举
        dp[0,...,W] = 0
        for i = 0 : N-1
            for j = w[i] : W
                dp[j] = max(dp[j], dp[j-w[i]] + v[i])
        ```
3. 另一种思路，k为装入第i种物品的件数：`dp[i][j] = max{(dp[i-1][j − k*w[i]] + k*v[i]) for every k}`
    ```
    dp[0,...,W] = 0
    for i = 0 : N-1
        for j = W : w[i] // 逆向枚举
            for k = 0 : j/w[i]
                dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i])
    ```

### 3 多重背包
有限 n[i] 个 N 种物品，第i（i从1开始）件物品的重量为 w[i]，价值为 v[i]，能够装入背包的最大价值是多少？
- k 为装入第 i 种物品的件数：`dp[i][j] = max{(dp[i-1][j − k*w[i]] + k*v[i]) for every k}`
   ```
   dp[0,...,W] = 0
   for i = 0,...,N-1
       for j = W,...,w[i] // 必须逆向枚举!!!
           for k = [0, 1,..., min(n[i], j/w[i])]
               dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i])
   ```

### 额外情形
1. 恰好装满：初始化 dp[0,...,N][0] 为0，其余为 -inf
2. 求总方案数：将状态转移方程的 max 换为 sum：`dp[i][j] = sum(dp[i−1][j], dp[i][j−w[i]])`
3. 二维背包：背包有两个限制条件：dp 数组多开一维
4. 最优方案：用 G[i][j] 记录策略（0，1分别表示 dp[i][j] 的两种选择）

### Leetcode 相关题目
1. 416 分割等和子集：将正整数集合分割为两个等和子集（组合优化）
   ```cpp
   bool canPartition(vector<int>& nums) {
      int sum = 0;
      for (auto num : nums)
         sum += num;
      if (sum % 2 == 1) return false; // 和为奇数时必不能分割
   
      int capacity = sum / 2;
      vector<bool> dp(capacity+1, false); // dp[i][j] 表示和为 j 能否由前 i 个数字恰好得到
      dp[0] = true; // dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]]
      for (int i = 0; i < nums.size(); ++i) {
         for (int j = capacity; j >= nums[i]; --j) {
            dp[j] = dp[j] || dp[j - nums[i-1]];
         }
      }
      return dp[capacity];
   }
   ```
