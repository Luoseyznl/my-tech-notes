> 动态规划核心思想：避免重复计算

### 1 01背包问题
- 本质：组合优化的 NP 完全问题
第 i（i 从1开始）件物品的重量为 w[i]，价值为 v[i]，能够装入背包的最大价值是多少？
1. 动态规划：`dp[i][j]` 表示前 `i` 个物品放入 限重为 `j` 的背包的最大价值
2. `dp[i][j]` 两种情况：`dp[i-1][j]` or `dp[i-1][j-w[i]] + v[i]`（装入或不装入第 i 个物品）
3. 状态转移方程：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])`
   - `dp[i][j]` 仅与 `dp[i-1][0,...,j-1]` 有关 ==> 采用滚动数组优化（去掉第一维）+ **逆向枚举**
   - 伪代码
        ```
        // 空间优化、逆向枚举
        dp[0,...,W] = 0
        for i = 1 : N
            for j = W : w[i]
                dp[j] = max(dp[j], dp[j-w[i]] + v[i])
        ```
### 2 完全背包
N 种物品各无限多个，第i（i从1开始）件物品的重量为 w[i]，价值为 v[i]，能够装入背包的最大价值是多少？
1. 动态规划：仍然用 `dp[i][j]` 表示前 `i` 种物品放入 限重为 `j` 的背包的最大价值
2. 状态转移方程：`dp[i][j]` 两种情况：`dp[i-1][j]` or `dp[i][j-w[i]] + v[i]`（区别）
   - 仍采用滚动数组优化，但**正向枚举**（每一次的规划都要覆盖上一次）

        ```
        \\ 空间优化、正向枚举
        dp[0,...,W] = 0
        for i = 0 : N-1
            for j = w[i] : W
                dp[j] = max(dp[j], dp[j-w[i]] + v[i])
        ```
3. 另一种思路，k为装入第i种物品的件数：`dp[i][j] = max{(dp[i-1][j − k*w[i]] + k*v[i]) for every k}`
    ```
    dp[0,...,W] = 0
    for i = 0 : N-1
        for j = W : w[i] // 逆向枚举
            for k = 0 : j/w[i]
                dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i])
    ```

### 3 多重背包
有限 n[i] 个 N 种物品，第i（i从1开始）件物品的重量为 w[i]，价值为 v[i]，能够装入背包的最大价值是多少？
- k 为装入第 i 种物品的件数：`dp[i][j] = max{(dp[i-1][j − k*w[i]] + k*v[i]) for every k}`
   ```
   dp[0,...,W] = 0
   for i = 0,...,N-1
       for j = W,...,w[i] // 必须逆向枚举!!!
           for k = [0, 1,..., min(n[i], j/w[i])]
               dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i])
   ```

### 额外情形
1. 恰好装满：初始化 dp[0,...,N][0] 为0，其余为 -inf
2. 求总方案数：将状态转移方程的 max 换为 sum：`dp[i][j] = sum(dp[i−1][j], dp[i][j−w[i]])`
3. 二维背包：背包有两个限制条件：dp 数组多开一维
4. 最优方案：用 G[i][j] 记录策略（0，1分别表示 dp[i][j] 的两种选择）

### Leetcode 相关题目
1. 416 分割等和子集：将正整数集合分割为两个等和子集（01背包（恰好） 组合优化）
   ```cpp
   bool canPartition(vector<int>& nums) {
      int sum = 0;
      for (auto num : nums)
         sum += num;
      if (sum % 2 == 1) return false; // 和为奇数时必不能分割
   
      int capacity = sum / 2;
      vector<bool> dp(capacity+1, false); // dp[i][j] 表示和为 j 能否由前 i+1 个数字恰好得到
      dp[0] = true; // dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]]
      for (int i = 0; i < nums.size(); ++i) {
         for (int j = capacity; j >= nums[i]; --j) {
            dp[j] = dp[j] || dp[j - nums[i-1]];
         }
      }
      return dp[capacity];
   }
   ```
2. 322 零钱兑换：将无限个零钱组合成目标值（完全背包（恰好） 组合优化）
   ```
   int coinChange(vector<int>& coins, int amount) {
      vector<int> dp(amount+1, INT_MAX); // dp[i][j] 表示和恰好为 j 的前 i+1 种硬币的最少个数
      dp[0] = 0; // 面值 0 恰好由 0 种硬币得到
   
      for (int i = 0; i < coins.size(); ++i) {
         for (int j = coins[i]; j <= amount; ++j) {
            // 溢出：dp[j] = min(dp[j], dp[j-coins[i]]+1); // dp[i][j] = min(dp[i-1][j], dp[i][j-coins[i]]+1)
            if (dp[j]-1 > dp[j-coins[i]]+1) dp[j] = 1 + dp[j-coins[i]];
         }
      }
      return dp[amount] == INT_MAX ? -1 : dp[amount];
   }
   ```
3. 494 目标和：给数组数字加上正负号以得到目标值（01背包（组合数）组合优化）
   ```
   // sum = A+B, S = A-B => A = (sum+S) / 2;
   int findTargetSumWays(vector<int>& nums, int S) {
      int sum = 0;
      sum = accumulate(nums.begin(), nums.end(), 0);
      if (S > sum || sum < -S) return 0;
      if ((S+sum) & 1) return 0; // A 不能为奇数
      int target = (S+sum) >> 1;
      vector<int> dp(target+1, 0); // dp[i][j] 表示和恰好为 j 的前 i+1 个数字的组合数
      dp[0] = 1;
      for (int i = 0; i <= nums.size()-1; ++i)
         for (int j = target; j >= nums[i]; --j) {
            dp[j] = dp[j] + dp[j-nums[i]]+1;
         }
      return dp[target];
   }
   ```
4. 474 1 和 0：从字符串数组中选取尽可能长的字符串，其中 0 和 1 不超过 m 和 n
   ```cpp
   int findMaxForm(vector<string>& strs, int m, int n) {
      
      for (int i = 0; i < strs.size(); ++i) {
         int w0 = 0, w1 = 0;
         for (char& c: strs[i]) {
            if (c == '0') w0 += 1;
            else if (c == '1') w1 += 1;
         }
   
         for (int j = m; j >= w0; --j)
            for (int k = n; k >= w1; --k)
               dp[j][k] = max(dp[j][k], 1+dp[j-w0][k-w1]);
      }
   }
   ```

